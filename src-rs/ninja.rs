/*
Copyright 2025 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

use std::ffi::{OsStr, OsString};
use std::fs::OpenOptions;
use std::io::Write;
use std::os::unix::ffi::OsStrExt;
use std::os::unix::fs::OpenOptionsExt;
use std::time::SystemTime;
use std::{
    collections::{HashMap, HashSet},
    sync::Arc,
};

use anyhow::Result;
use bytes::{Buf, BufMut, Bytes, BytesMut};
use memchr::{memchr2, memmem};
use parking_lot::Mutex;

use crate::func::CommandOp;
use crate::io::{dump_int, dump_string, dump_systemtime, dump_usize, dump_vec_string};
use crate::strutil::{basename, concat_dir, dirname, strip_ext, strip_ext_vec};
use crate::{
    command::{Command, CommandEvaluator},
    dep::{DepNode, NamedDepNode, is_special_target},
    eval::Evaluator,
    expr::Evaluable,
    flags::FLAGS,
    strutil::{escape_shell, trim_left_space},
    symtab::{Symbol, intern},
    timeutil::ScopedTimeReporter,
    var::USED_ENV_VARS,
};
use crate::{error, file_cache};

fn find_command_line_flag(cmd: &[u8], name: &[u8]) -> Option<usize> {
    match memmem::find(cmd, name) {
        Some(0) => None,
        found => found,
    }
}

fn find_command_line_flag_with_arg(cmd: &[u8], name: &[u8]) -> Option<Vec<u8>> {
    let idx = find_command_line_flag(cmd, name)?;

    let mut val = trim_left_space(&cmd[idx + name.len()..]);
    while let Some(idx) = memmem::find(val, name) {
        val = trim_left_space(&val[idx + name.len()..]);
    }

    let Some(idx) = memchr2(b' ', b'\t', val) else {
        return Some(val.to_vec());
    };
    Some(val[..idx].to_vec())
}

fn get_depfile_from_command_impl(cmd: &mut BytesMut) -> Result<Option<Vec<u8>>> {
    if (find_command_line_flag(cmd, b" -MD").is_none()
        && find_command_line_flag(cmd, b" -MMD").is_none())
        || find_command_line_flag(cmd, b" -c").is_none()
    {
        return Ok(None);
    }

    if let Some(mf) = find_command_line_flag_with_arg(cmd, b" -MF") {
        return Ok(Some(mf));
    }

    let Some(o) = find_command_line_flag_with_arg(cmd, b" -o") else {
        error!(
            "Cannot find the depfile in {}",
            String::from_utf8_lossy(cmd.as_ref())
        );
    };

    let mut o = strip_ext_vec(o);
    o.extend_from_slice(b".d");
    Ok(Some(o))
}

fn get_depfile_from_command(cmd: &mut BytesMut) -> Result<Option<Bytes>> {
    assert!(!cmd.is_empty());
    let Some(mut out) = get_depfile_from_command_impl(cmd)? else {
        return Ok(None);
    };

    // A hack for Android - llvm-rs-cc seems not to emit a dep file.
    if memmem::find(cmd, b"bin/llvm-rs-cc ").is_some() {
        return Ok(None);
    }

    // TODO: A hack for Makefiles generated by automake.

    // A hack for Android to get .P files instead of .d.
    let mut p = strip_ext_vec(out.clone());
    p.extend_from_slice(b".P");
    if memmem::find(cmd, &p).is_some() {
        let mut rm_f = b"; rm -f ".to_vec();
        rm_f.extend_from_slice(&out);
        let Some(found) = memmem::find(cmd, &rm_f) else {
            error!(
                "Cannot find remove of .d file: {}",
                String::from_utf8_lossy(cmd.as_ref())
            );
        };
        let after = cmd[found + rm_f.len()..].to_vec();
        cmd.truncate(found);
        cmd.extend_from_slice(&after);
        return Ok(Some(Bytes::from(out)));
    }

    // A hack for Android. For .s files, GCC does not use C
    // preprocessor, so it ignores -MF flag.
    let mut a_s = b"/".to_vec();
    a_s.extend_from_slice(strip_ext(basename(&out)));
    a_s.extend_from_slice(b".s");
    if memmem::find(cmd, &a_s).is_some() {
        return Ok(None);
    }

    cmd.extend_from_slice(b"&& cp ");
    cmd.extend_from_slice(&out);
    cmd.put_u8(b' ');
    cmd.extend_from_slice(&out);
    cmd.extend_from_slice(b".tmp ");
    out.extend_from_slice(b".tmp");
    Ok(Some(Bytes::from(out)))
}

struct NinjaNode {
    node: Arc<Mutex<DepNode>>,
    commands: Vec<Command>,
    rule_id: Option<usize>,
}

struct NinjaGenerator<'a> {
    ce: CommandEvaluator<'a>,
    done: HashSet<Symbol>,
    rule_id: usize,
    shell: Bytes,
    shell_flags: Bytes,
    used_envs: HashMap<Symbol, OsString>,
    kati_binary: OsString,
    start_time: SystemTime,
    nodes: Vec<NinjaNode>,
    default_target: Mutex<Option<Arc<Mutex<DepNode>>>>,
}

impl<'a> NinjaGenerator<'a> {
    fn new(ce: CommandEvaluator<'a>, start_time: SystemTime) -> Result<Self> {
        let shell = Self::escape_ninja(&ce.ev.get_shell()?);
        let shell_flags = Self::escape_ninja(&Bytes::from_static(ce.ev.get_shell_flag()));
        ce.ev.avoid_io = true;
        Ok(Self {
            ce,
            done: HashSet::new(),
            rule_id: 0,
            shell,
            shell_flags,
            used_envs: HashMap::new(),
            kati_binary: OsString::from(std::env::current_exe().unwrap()),
            start_time,
            nodes: Vec::new(),
            default_target: Mutex::new(None),
        })
    }

    fn generate(&mut self, nodes: &Vec<NamedDepNode>, orig_args: &[u8]) -> Result<()> {
        let _ = std::fs::remove_file(Self::get_stamp_temp_filename());
        self.populate_ninja_nodes(nodes)?;
        self.generate_ninja()?;
        self.generate_shell()?;
        self.generate_stamp(orig_args)?;
        Ok(())
    }

    fn get_stamp_temp_filename() -> OsString {
        ninja_file(".kati_stamp", ".tmp")
    }

    fn populate_ninja_nodes(&mut self, nodes: &Vec<NamedDepNode>) -> Result<()> {
        let _tr = ScopedTimeReporter::new("ninja gen (eval)");
        for (_symbol, depnode) in nodes {
            self.populate_ninja_node(depnode)?;
        }
        Ok(())
    }

    fn populate_ninja_node(&mut self, node: &Arc<Mutex<DepNode>>) -> Result<()> {
        let output = node.lock().output;
        if self.done.contains(&output) {
            return Ok(());
        }
        self.done.insert(output);
        let loc;
        let has_rule;
        let is_phony;
        {
            let node = node.lock();
            loc = node.loc.clone();
            has_rule = node.has_rule;
            is_phony = node.is_phony;
        }
        let _frame = self.ce.ev.enter(
            crate::eval::FrameType::Ninja,
            output.as_bytes(),
            loc.unwrap_or_default(),
        );

        // A hack to exclude out phony target in Android. If this exists,
        // "ninja -t clean" tries to remove this directory and fails.
        if FLAGS.detect_android_echo && output.as_bytes().as_ref() == b"out" {
            return Ok(());
        }

        // This node is a leaf node
        if !has_rule && !is_phony {
            return Ok(());
        }

        let commands = self.ce.eval(node)?;
        let rule_id = if commands.is_empty() {
            None
        } else {
            let id = self.rule_id;
            self.rule_id += 1;
            Some(id)
        };

        self.nodes.push(NinjaNode {
            node: node.clone(),
            commands,
            rule_id,
        });

        let deps = node.lock().deps.clone();
        for (_symbol, depnode) in deps {
            self.populate_ninja_node(&depnode)?;
        }

        let order_onlys = node.lock().order_onlys.clone();
        for (_symbol, depnode) in order_onlys {
            self.populate_ninja_node(&depnode)?;
        }

        let validations = node.lock().validations.clone();
        for (_symbol, depnode) in validations {
            self.populate_ninja_node(&depnode)?;
        }

        Ok(())
    }

    fn translate_command(inp: Bytes) -> Bytes {
        let mut cmd_buf = BytesMut::new();
        let mut prev_backslash = false;
        // Set space as an initial value so the leading comment will be
        // stripped out.
        let mut prev_char = b' ';
        let mut quote = None;
        let mut inp = inp;
        while let Some(&c) = inp.first() {
            match c {
                b'#' => {
                    if quote.is_none() && prev_char.is_ascii_whitespace() {
                        while inp.len() > 1 && inp[0] != b'\n' {
                            inp.advance(1);
                        }
                    } else {
                        cmd_buf.put_u8(c);
                    }
                }
                b'\'' | b'"' | b'`' => {
                    if let Some(q) = quote {
                        if q == c {
                            quote = None;
                        }
                    } else if !prev_backslash {
                        quote = Some(c);
                    }
                    cmd_buf.put_u8(c);
                }
                b'$' => cmd_buf.put_slice(b"$$"),
                b'\n' => {
                    if prev_backslash {
                        cmd_buf.truncate(cmd_buf.len() - 1);
                    } else {
                        cmd_buf.put_u8(b' ');
                    }
                }
                _ => cmd_buf.put_u8(c),
            }

            if c == b'\\' {
                prev_backslash = !prev_backslash;
            } else {
                prev_backslash = false;
            }

            prev_char = c;
            inp.advance(1);
        }

        if prev_backslash {
            cmd_buf.truncate(cmd_buf.len() - 1);
        }

        while !cmd_buf.is_empty() {
            let c = *cmd_buf.last().unwrap();
            if !c.is_ascii_whitespace() && c != b';' {
                break;
            }
            cmd_buf.truncate(cmd_buf.len() - 1);
        }

        cmd_buf.freeze()
    }

    fn is_output_mkdir(name: &Bytes, cmd: &Bytes) -> bool {
        let Some(cmd) = cmd.strip_prefix(b"mkdir -p ") else {
            return false;
        };

        let cmd = match cmd.strip_suffix(b"/") {
            Some(c) => c,
            None => cmd,
        };

        cmd == dirname(name)
    }

    fn get_description_from_command(cmd: &Bytes, out: &mut Bytes) -> bool {
        let Some(cmd) = cmd.strip_prefix(b"echo ") else {
            return false;
        };

        let mut prev_backslash = false;
        let mut quote = None;
        let mut out_buf = BytesMut::new();

        // Strip outer quotes, and fail if it is not a single echo command
        for c in cmd {
            let c = *c;
            if prev_backslash {
                prev_backslash = false;
                out_buf.put_u8(c);
            } else if c == b'\\' {
                prev_backslash = true;
                out_buf.put_u8(c);
            } else if let Some(q) = quote {
                if c == q {
                    quote = None;
                } else {
                    out_buf.put_u8(c);
                }
            } else {
                match c {
                    b'\'' | b'"' | b'`' => quote = Some(c),
                    b'<' | b'>' | b'&' | b'|' | b';' => return false,
                    _ => out_buf.put_u8(c),
                }
            }
        }

        *out = out_buf.freeze();
        true
    }

    fn gen_shell_script(
        name: &Bytes,
        commands: &Vec<Command>,
        cmd_buf: &mut BytesMut,
        description: &mut Bytes,
    ) {
        let mut got_description = false;
        let mut command_count = commands.len();
        for c in commands {
            let inp = c.cmd.slice_ref(c.cmd.trim_ascii_start());

            let needs_subshell = (command_count > 1 || c.ignore_error) && !c.force_no_subshell;

            let mut translated = Self::translate_command(inp);
            if FLAGS.detect_android_echo
                && !got_description
                && !c.echo
                && Self::get_description_from_command(&translated, description)
            {
                got_description = true;
                translated.clear();
            } else if Self::is_output_mkdir(name, &translated) && !c.echo && cmd_buf.is_empty() {
                translated.clear();
            }
            if translated.is_empty() {
                command_count -= 1;
                continue;
            }

            if !cmd_buf.is_empty() {
                cmd_buf.put_slice(b" && ");
            }

            if needs_subshell {
                cmd_buf.put_u8(b'(');
            }

            cmd_buf.put_slice(&translated);

            if c.ignore_error {
                cmd_buf.put_slice(b" ; true");
            }

            if needs_subshell {
                cmd_buf.put_slice(b" )");
            }
        }
    }

    fn get_depfile(&mut self, node: &DepNode, cmd_buf: &mut BytesMut) -> Result<Option<Bytes>> {
        if let Some(depfile_var) = node.depfile_var.clone() {
            let depfile = depfile_var.read().eval_to_buf(self.ce.ev)?;
            return Ok(Some(depfile));
        }
        if !FLAGS.detect_depfiles {
            return Ok(None);
        }

        cmd_buf.put_u8(b' ');
        let result = get_depfile_from_command(cmd_buf);
        cmd_buf.truncate(cmd_buf.len() - 1);
        result
    }

    fn emit_depfile(
        &mut self,
        node: &DepNode,
        cmd_buf: &mut BytesMut,
        out: &mut impl std::io::Write,
    ) -> Result<()> {
        if let Some(depfile) = self.get_depfile(node, cmd_buf)? {
            write!(out, " depfile = ")?;
            out.write_all(&depfile)?;
            writeln!(out, "\n deps = gcc")?;
        }
        Ok(())
    }

    fn emit_node(&mut self, nn: &NinjaNode, out: &mut impl std::io::Write) -> Result<()> {
        let node = nn.node.lock();
        let commands = &nn.commands;

        let mut rule_name = "phony".to_string();
        let use_local_pool = FLAGS.remote_num_jobs > 0;
        if is_special_target(&node.output) {
            return Ok(());
        }
        if FLAGS.enable_debug {
            writeln!(out, "# {}", node.loc.clone().unwrap_or_default())?;
        }
        if !commands.is_empty() {
            rule_name = format!("rule{}", nn.rule_id.unwrap());
            writeln!(out, "rule {rule_name}")?;

            let mut description = Bytes::from_static(b"build $out");
            let mut cmd_buf = BytesMut::new();
            Self::gen_shell_script(
                &node.output.as_bytes(),
                commands,
                &mut cmd_buf,
                &mut description,
            );
            out.write_all(b" description = ")?;
            out.write_all(&description)?;
            out.write_all(b"\n")?;
            self.emit_depfile(&node, &mut cmd_buf, out)?;

            // It seems Linux is OK with ~130kB and Mac's limit is ~250kB.
            // TODO: Find this number automatically.
            if cmd_buf.len() > 100 * 1000 {
                writeln!(out, " rspfile = $out.rsp")?;
                write!(out, " rspfile_content = ")?;
                out.write_all(&cmd_buf)?;
                write!(out, "\n command = ")?;
                out.write_all(&self.shell)?;
                writeln!(out, " $out.rsp")?;
            } else {
                out.write_all(b" command = ")?;
                out.write_all(&self.shell)?;
                out.write_all(b" ")?;
                out.write_all(&self.shell_flags)?;
                out.write_all(b" \"")?;
                out.write_all(&escape_shell(&cmd_buf.freeze()))?;
                writeln!(out, "\"")?;
            }
            if node.is_restat {
                writeln!(out, " restat = 1")?;
            }
        }

        self.emit_build(nn, &node, rule_name, use_local_pool, out)
    }

    fn escape_ninja(s: &Bytes) -> Bytes {
        let extras = s.iter().filter(|c| b"$: ".contains(c)).count();
        if extras == 0 {
            return s.clone();
        }
        let mut r = BytesMut::with_capacity(s.len() + extras);
        for c in s {
            let c = *c;
            match c {
                b'$' | b':' | b' ' => {
                    r.put_u8(b'$');
                    r.put_u8(c);
                }
                _ => r.put_u8(c),
            }
        }
        r.freeze()
    }

    fn escape_build_target(s: Symbol) -> Bytes {
        Self::escape_ninja(&s.as_bytes())
    }

    fn emit_build(
        &mut self,
        nn: &NinjaNode,
        node: &DepNode,
        rule_name: String,
        use_local_pool: bool,
        out: &mut impl std::io::Write,
    ) -> Result<()> {
        let target = Self::escape_build_target(node.output);
        write!(out, "build ")?;
        out.write_all(&target)?;
        if !node.implicit_outputs.is_empty() {
            write!(out, " |")?;
            for output in &node.implicit_outputs {
                out.write_all(b" ")?;
                out.write_all(&Self::escape_build_target(*output))?;
            }
        }
        write!(out, ": {rule_name}")?;
        if node.is_phony && !FLAGS.use_ninja_phony_output {
            write!(out, " _kati_always_build_")?;
        }
        for (s, _) in &node.deps {
            out.write_all(b" ")?;
            out.write_all(&Self::escape_build_target(*s))?;
        }
        if !node.order_onlys.is_empty() {
            write!(out, " ||")?;
            for (s, _) in &node.order_onlys {
                out.write_all(b" ")?;
                out.write_all(&Self::escape_build_target(*s))?;
            }
        }
        if !node.validations.is_empty() {
            write!(out, " |@")?;
            for (s, _) in &node.validations {
                out.write_all(b" ")?;
                out.write_all(&Self::escape_build_target(*s))?;
            }
        }

        writeln!(out)?;

        let pool = if let Some(ninja_pool_var) = &node.ninja_pool_var {
            Some(ninja_pool_var.read().eval_to_buf(self.ce.ev)?)
        } else {
            None
        };

        if pool.as_ref().is_some_and(|pool| !pool.is_empty()) {
            let pool = pool.unwrap();
            if pool.as_ref() != b"none" {
                write!(out, " pool = ")?;
                out.write_all(&pool)?;
                out.write_all(b"\n")?;
            }
        } else if !FLAGS.default_pool.is_empty() && rule_name != "phony" {
            write!(out, " pool = ")?;
            out.write_all(FLAGS.default_pool.as_bytes())?;
            out.write_all(b"\n")?;
        } else if use_local_pool {
            writeln!(out, " pool = local_pool")?;
        }
        if node.is_phony && FLAGS.use_ninja_phony_output {
            writeln!(out, " phony_output = true")?;
        }
        if let Some(tags_var) = &node.tags_var {
            let tags = tags_var.read().eval_to_buf(self.ce.ev)?;
            if !tags.is_empty() {
                write!(out, " tags = ")?;
                out.write_all(&tags)?;
                writeln!(out)?;
            }
        }
        if node.is_default_target {
            *self.default_target.lock() = Some(nn.node.clone());
        }
        Ok(())
    }

    fn get_env_script_filename() -> OsString {
        ninja_file("env", ".sh")
    }

    fn generate_ninja(&mut self) -> Result<()> {
        let _tr = ScopedTimeReporter::new("ninja gen (emit)");
        let out = std::fs::File::create(get_ninja_filename())?;
        let mut out = std::io::BufWriter::new(out);

        write!(out, "# Generated by kati unknown\n\n")?;

        if !self.used_envs.is_empty() {
            writeln!(out, "# Environment variables used:")?;
            for (key, value) in &self.used_envs {
                write!(out, "# {key}=")?;
                out.write_all(value.as_bytes())?;
                out.write_all(b"\n")?;
            }
            writeln!(out)?;
        }

        if !FLAGS.no_ninja_prelude {
            if let Some(ninja_dir) = &FLAGS.ninja_dir {
                write!(out, "builddir = ")?;
                out.write_all(ninja_dir.as_bytes())?;
                out.write_all(b"\n\n")?;
            }

            writeln!(out, "pool local_pool\n depth = {}\n", FLAGS.num_jobs)?;

            if !FLAGS.use_ninja_phony_output {
                writeln!(out, "build _kati_always_build_: phony\n")?;
            }
        }

        if !FLAGS.generate_empty_ninja {
            for node in std::mem::take(&mut self.nodes) {
                self.emit_node(&node, &mut out)?;
            }

            write!(out, "\ndefault ")?;
            if FLAGS.targets.is_empty() || FLAGS.gen_all_targets {
                out.write_all(&Self::escape_build_target(
                    self.default_target.lock().as_ref().unwrap().lock().output,
                ))?;
            } else {
                let mut empty = true;
                for s in &FLAGS.targets {
                    if !empty {
                        out.write_all(b" ")?;
                    }
                    out.write_all(&Self::escape_build_target(*s))?;
                    empty = false;
                }
            }
            out.write_all(b"\n")?;
        }

        let mut used_env_vars = USED_ENV_VARS.lock().clone();
        // PATH changes $(shell).
        used_env_vars.insert(intern("PATH"));
        for e in used_env_vars {
            let k = e.as_bytes();
            let k = OsStr::from_bytes(&k);
            let val = std::env::var_os(k).unwrap();
            self.used_envs.insert(e, val);
        }

        Ok(())
    }

    fn generate_shell(&mut self) -> Result<()> {
        {
            let out = std::fs::File::create(Self::get_env_script_filename())?;
            let mut out = std::io::BufWriter::new(out);

            writeln!(out, "#!/bin/sh")?;
            writeln!(out, "# Generated by kati unknown\n")?;

            let exports = self.ce.ev.exports.clone();
            for (symbol, is_exported) in exports {
                if is_exported {
                    let val = self.ce.ev.eval_var(symbol)?;
                    write!(out, "export '{symbol}'='")?;
                    out.write_all(&val)?;
                    writeln!(out, "'")?;
                } else {
                    writeln!(out, "unset '{symbol}'")?;
                }
            }
        }

        {
            let mut opts = OpenOptions::new();
            opts.create(true).write(true).mode(0o755);
            let out = opts.open(get_ninja_shell_script_filename())?;
            let mut out = std::io::BufWriter::new(out);

            writeln!(out, "#!/bin/sh")?;
            writeln!(out, "# Generated by kati unknown\n")?;

            write!(out, ". ")?;
            out.write_all(Self::get_env_script_filename().as_bytes())?;

            write!(out, "\nexec ninja -f ")?;
            out.write_all(get_ninja_filename().as_bytes())?;
            out.write_all(b" ")?;
            if FLAGS.remote_num_jobs > 0 {
                write!(out, "-j{} ", FLAGS.remote_num_jobs)?;
            }
            writeln!(out, "\"$@\"")?;
        }
        Ok(())
    }

    fn generate_stamp(&self, orig_args: &[u8]) -> Result<()> {
        {
            let out = std::fs::File::create(Self::get_stamp_temp_filename())?;
            let mut out = std::io::BufWriter::new(out);

            dump_systemtime(&mut out, &self.start_time)?;

            let makefiles = file_cache::get_all_filenames();
            dump_usize(&mut out, makefiles.len() + 1)?;
            dump_string(&mut out, self.kati_binary.as_bytes())?;
            for makefile in makefiles {
                dump_string(&mut out, makefile.as_bytes())?;
            }

            dump_usize(&mut out, Evaluator::used_undefined_vars().len())?;
            for v in Evaluator::used_undefined_vars() {
                dump_string(&mut out, &v.as_bytes())?;
            }
            dump_usize(&mut out, self.used_envs.len())?;
            for (key, value) in &self.used_envs {
                dump_string(&mut out, &key.as_bytes())?;
                dump_string(&mut out, value.as_bytes())?;
            }

            let globs = crate::fileutil::GLOB_CACHE.lock();
            let globs: Vec<(&Bytes, &crate::fileutil::GlobResults)> = globs
                .iter()
                .filter_map(|(key, files)| {
                    if files.is_err() {
                        return None;
                    }
                    Some((key, files))
                })
                .collect();
            dump_usize(&mut out, globs.len())?;
            for (key, files) in globs.iter() {
                dump_string(&mut out, key)?;
                let Ok(files) = files.as_ref() else { continue };
                dump_vec_string(&mut out, files)?;
            }

            let crs = crate::func::COMMAND_RESULTS.lock();
            dump_usize(&mut out, crs.len())?;
            for cr in crs.iter() {
                dump_int(&mut out, cr.op.as_int())?;
                dump_string(&mut out, &cr.shell)?;
                dump_string(&mut out, &cr.shellflag)?;
                dump_string(&mut out, &cr.cmd)?;
                dump_string(&mut out, &cr.result)?;
                dump_string(&mut out, &cr.loc.filename.as_bytes())?;
                dump_int(&mut out, cr.loc.line)?;

                if cr.op == CommandOp::Find {
                    let fc = cr.find.as_ref().unwrap();
                    let chdir = fc.chdir.clone().unwrap_or_else(Bytes::new);
                    let mut missing_dirs = Vec::new();
                    for fd in &fc.finddirs {
                        let d = concat_dir(&chdir, fd);
                        if !std::fs::exists(OsStr::from_bytes(&d)).unwrap_or(false) {
                            missing_dirs.push(d);
                        }
                    }
                    dump_vec_string(&mut out, &missing_dirs)?;

                    dump_usize(&mut out, fc.found_files.lock().len())?;
                    for s in fc.found_files.lock().iter() {
                        dump_string(&mut out, &concat_dir(&chdir, s))?;
                    }

                    dump_usize(&mut out, fc.read_dirs.lock().len())?;
                    for s in fc.read_dirs.lock().iter() {
                        dump_string(&mut out, &concat_dir(&chdir, s))?;
                    }
                }
            }

            dump_string(&mut out, orig_args)?;
        }
        std::fs::rename(Self::get_stamp_temp_filename(), get_ninja_stamp_filename())?;
        Ok(())
    }
}

impl Drop for NinjaGenerator<'_> {
    fn drop(&mut self) {
        self.ce.ev.avoid_io = false;
    }
}

pub fn get_ninja_filename() -> OsString {
    ninja_file("build", ".ninja")
}

pub fn get_ninja_shell_script_filename() -> OsString {
    ninja_file("ninja", ".sh")
}

pub fn get_ninja_stamp_filename() -> OsString {
    ninja_file(".kati_stamp", "")
}

fn ninja_file(prefix: &str, suffix: &str) -> OsString {
    let mut r = FLAGS
        .ninja_dir
        .clone()
        .unwrap_or_else(|| OsString::from("."));
    r.push("/");
    r.push(prefix);
    r.push(&FLAGS.ninja_suffix);
    r.push(suffix);
    r
}

pub fn generate_ninja(
    nodes: &Vec<NamedDepNode>,
    ev: &mut Evaluator,
    orig_args: &[u8],
    start_time: SystemTime,
) -> Result<()> {
    let mut ng = NinjaGenerator::new(CommandEvaluator::new(ev)?, start_time)?;
    ng.generate(nodes, orig_args)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_desc(cmd: &'static [u8]) -> Option<String> {
        let mut description = Bytes::new();
        if NinjaGenerator::get_description_from_command(&Bytes::from_static(cmd), &mut description)
        {
            Some(String::from_utf8_lossy(description.as_ref()).to_string())
        } else {
            None
        }
    }

    #[test]
    fn test_get_description_from_command() {
        assert_eq!(get_desc(b"echo Hello"), Some("Hello".into()));
        assert_eq!(
            get_desc(b"echo \"Hello 'World'\""),
            Some("Hello 'World'".into())
        );
        assert_eq!(
            get_desc(b"echo Hello \\\" World"),
            Some("Hello \\\" World".into())
        );
    }

    #[test]
    fn test_translate_command() {
        assert_eq!(
            NinjaGenerator::translate_command(Bytes::from_static(b"echo Hello")),
            Bytes::from_static(b"echo Hello")
        );
    }

    fn get_depfile_and_cmd(cmd: &str) -> Result<(Option<String>, String)> {
        let mut cmd = BytesMut::from(cmd.as_bytes());
        let depfile = get_depfile_from_command(&mut cmd)?;
        Ok((
            depfile.map(|b| String::from_utf8_lossy(&b).to_string()),
            String::from_utf8_lossy(&cmd).to_string(),
        ))
    }
    fn get_depfile(cmd: &str) -> Result<Option<String>> {
        Ok(get_depfile_and_cmd(cmd)?.0)
    }

    #[test]
    fn test_get_depfile() -> Result<()> {
        assert!(get_depfile("g++ -c fat.cc -MD ").is_err());

        assert_eq!(get_depfile("g++ -c fat.cc -o fat.o")?, None);
        assert_eq!(
            get_depfile("g++ -c fat.cc -MD -o fat.o -o fuga.o")?,
            Some("fuga.d.tmp".into())
        );
        assert_eq!(
            get_depfile("g++ -c fat.cc -MD -o fat.o")?,
            Some("fat.d.tmp".into())
        );
        assert_eq!(
            get_depfile("g++ -c fat.cc -MD -o fat")?,
            Some("fat.d.tmp".into())
        );
        assert_eq!(
            get_depfile("g++ -c fat.cc -MD -MF foo.d -o fat.o")?,
            Some("foo.d.tmp".into())
        );
        assert_eq!(
            get_depfile("g++ -c fat.cc -MD -o fat.o -MF foo.d")?,
            Some("foo.d.tmp".into())
        );
        // A real example from maloader.
        assert_eq!(
            get_depfile(
                "g++ -g -Iinclude -Wall -MMD -fno-omit-frame-pointer -O -m64 -W -Werror   -c -o fat.o fat.cc"
            )?,
            Some("fat.d.tmp".into())
        );
        // A real example from Android.
        assert_eq!(
            get_depfile_and_cmd(
                "mkdir -p out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/ && echo \"host C++: llvm-rs-cc <= frameworks/compile/slang/llvm-rs-cc.cpp\" && prebuilts/clang/linux-x86/host/3.6/bin/clang++ -I external/llvm -I external/llvm/include -I external/llvm/host/include -I external/clang/include -I external/clang/lib/CodeGen -I frameworks/compile/libbcc/include -I out/host/linux-x86/gen/EXECUTABLES/llvm-rs-cc_intermediates/include -I external/libcxx/include -I frameworks/compile/slang -I out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates -I out/host/linux-x86/gen/EXECUTABLES/llvm-rs-cc_intermediates -I libnativehelper/include/nativehelper $(cat out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/import_includes) -isystem system/core/include -isystem hardware/libhardware/include -isystem hardware/libhardware_legacy/include -isystem hardware/ril/include -isystem libnativehelper/include -isystem frameworks/native/include -isystem frameworks/native/opengl/include -isystem frameworks/av/include -isystem frameworks/base/include -isystem tools/include -isystem out/host/linux-x86/obj/include -c    -fno-exceptions -Wno-multichar -m64 -Wa,--noexecstack -fPIC -no-canonical-prefixes -include build/core/combo/include/arch/linux-x86/AndroidConfig.h -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0 -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -DANDROID -fmessage-length=0 -W -Wall -Wno-unused -Winit-self -Wpointer-arith -O2 -g -fno-strict-aliasing -DNDEBUG -UDEBUG  -D__compiler_offsetof=__builtin_offsetof -Werror=int-conversion -Wno-unused-command-line-argument   --gcc-toolchain=prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8/    --gcc-toolchain=prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8/ --sysroot=prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8//sysroot -target x86_64-linux-gnu   -DANDROID -fmessage-length=0 -W -Wall -Wno-unused -Winit-self -Wpointer-arith -Wsign-promo -std=gnu++11 -DNDEBUG -UDEBUG  -Wno-inconsistent-missing-override   --gcc-toolchain=prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8/ --sysroot=prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8//sysroot -isystem prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8//x86_64-linux/include/c++/4.8 -isystem prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8//x86_64-linux/include/c++/4.8/x86_64-linux -isystem prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8//x86_64-linux/include/c++/4.8/backward -target x86_64-linux-gnu    -pedantic -Wcast-qual -Wno-long-long -Wno-sign-promo -Wall -Wno-unused-parameter -Wno-return-type -Werror -std=c++11 -O0 -DTARGET_BUILD_VARIANT=eng -DRS_VERSION=23 -D_GNU_SOURCE -D__STDC_LIMIT_MACROS -O2 -fomit-frame-pointer -Wall -W -Wno-unused-parameter -Wwrite-strings -Dsprintf=sprintf -pedantic -Wcast-qual -Wno-long-long -Wno-sign-promo -Wall -Wno-unused-parameter -Wno-return-type -Werror -std=c++11 -O0 -DTARGET_BUILD_VARIANT=eng -DRS_VERSION=23 -fno-exceptions -fpie -D_USING_LIBCXX   -Wno-sign-promo -fno-rtti -Woverloaded-virtual -Wno-sign-promo -std=c++11 -nostdinc++  -MD -MF out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.d -o out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.o frameworks/compile/slang/llvm-rs-cc.cpp && cp out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.d out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.P; sed -e 's/#.*//' -e 's/^[^:]*: *//' -e 's/ *\\$//' -e '/^$/ d' -e 's/$/ :/' < out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.d >> out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.P; rm -f out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.d"
            )?,
            (
                Some("out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.d".into()),
                "mkdir -p out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/ && echo \"host C++: llvm-rs-cc <= frameworks/compile/slang/llvm-rs-cc.cpp\" && prebuilts/clang/linux-x86/host/3.6/bin/clang++ -I external/llvm -I external/llvm/include -I external/llvm/host/include -I external/clang/include -I external/clang/lib/CodeGen -I frameworks/compile/libbcc/include -I out/host/linux-x86/gen/EXECUTABLES/llvm-rs-cc_intermediates/include -I external/libcxx/include -I frameworks/compile/slang -I out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates -I out/host/linux-x86/gen/EXECUTABLES/llvm-rs-cc_intermediates -I libnativehelper/include/nativehelper $(cat out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/import_includes) -isystem system/core/include -isystem hardware/libhardware/include -isystem hardware/libhardware_legacy/include -isystem hardware/ril/include -isystem libnativehelper/include -isystem frameworks/native/include -isystem frameworks/native/opengl/include -isystem frameworks/av/include -isystem frameworks/base/include -isystem tools/include -isystem out/host/linux-x86/obj/include -c    -fno-exceptions -Wno-multichar -m64 -Wa,--noexecstack -fPIC -no-canonical-prefixes -include build/core/combo/include/arch/linux-x86/AndroidConfig.h -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0 -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -DANDROID -fmessage-length=0 -W -Wall -Wno-unused -Winit-self -Wpointer-arith -O2 -g -fno-strict-aliasing -DNDEBUG -UDEBUG  -D__compiler_offsetof=__builtin_offsetof -Werror=int-conversion -Wno-unused-command-line-argument   --gcc-toolchain=prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8/    --gcc-toolchain=prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8/ --sysroot=prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8//sysroot -target x86_64-linux-gnu   -DANDROID -fmessage-length=0 -W -Wall -Wno-unused -Winit-self -Wpointer-arith -Wsign-promo -std=gnu++11 -DNDEBUG -UDEBUG  -Wno-inconsistent-missing-override   --gcc-toolchain=prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8/ --sysroot=prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8//sysroot -isystem prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8//x86_64-linux/include/c++/4.8 -isystem prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8//x86_64-linux/include/c++/4.8/x86_64-linux -isystem prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8//x86_64-linux/include/c++/4.8/backward -target x86_64-linux-gnu    -pedantic -Wcast-qual -Wno-long-long -Wno-sign-promo -Wall -Wno-unused-parameter -Wno-return-type -Werror -std=c++11 -O0 -DTARGET_BUILD_VARIANT=eng -DRS_VERSION=23 -D_GNU_SOURCE -D__STDC_LIMIT_MACROS -O2 -fomit-frame-pointer -Wall -W -Wno-unused-parameter -Wwrite-strings -Dsprintf=sprintf -pedantic -Wcast-qual -Wno-long-long -Wno-sign-promo -Wall -Wno-unused-parameter -Wno-return-type -Werror -std=c++11 -O0 -DTARGET_BUILD_VARIANT=eng -DRS_VERSION=23 -fno-exceptions -fpie -D_USING_LIBCXX   -Wno-sign-promo -fno-rtti -Woverloaded-virtual -Wno-sign-promo -std=c++11 -nostdinc++  -MD -MF out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.d -o out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.o frameworks/compile/slang/llvm-rs-cc.cpp && cp out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.d out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.P; sed -e 's/#.*//' -e 's/^[^:]*: *//' -e 's/ *\\$//' -e '/^$/ d' -e 's/$/ :/' < out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.d >> out/host/linux-x86/obj/EXECUTABLES/llvm-rs-cc_intermediates/llvm-rs-cc.P".into()
            )
        );
        assert_eq!(
            get_depfile(
                "echo \"target asm: libsonivox <= external/sonivox/arm-wt-22k/lib_src/ARM-E_filter_gnu.s\" && mkdir -p out/target/product/generic/obj/SHARED_LIBRARIES/libsonivox_intermediates/lib_src/ && prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-gcc -I external/sonivox/arm-wt-22k/host_src -I external/sonivox/arm-wt-22k/lib_src -I external/libcxx/include -I external/sonivox/arm-wt-22k -I out/target/product/generic/obj/SHARED_LIBRARIES/libsonivox_intermediates -I out/target/product/generic/gen/SHARED_LIBRARIES/libsonivox_intermediates -I libnativehelper/include/nativehelper $$(cat out/target/product/generic/obj/SHARED_LIBRARIES/libsonivox_intermediates/import_includes) -isystem system/core/include -isystem hardware/libhardware/include -isystem hardware/libhardware_legacy/include -isystem hardware/ril/include -isystem libnativehelper/include -isystem frameworks/native/include -isystem frameworks/native/opengl/include -isystem frameworks/av/include -isystem frameworks/base/include -isystem out/target/product/generic/obj/include -isystem bionic/libc/arch-arm/include -isystem bionic/libc/include -isystem bionic/libc/kernel/uapi -isystem bionic/libc/kernel/uapi/asm-arm -isystem bionic/libm/include -isystem bionic/libm/include/arm -c  -fno-exceptions -Wno-multichar -msoft-float -ffunction-sections -fdata-sections -funwind-tables -fstack-protector -Wa,--noexecstack -Werror=format-security -D_FORTIFY_SOURCE=2 -fno-short-enums -no-canonical-prefixes -fno-canonical-system-headers -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16 -include build/core/combo/include/arch/linux-arm/AndroidConfig.h -I build/core/combo/include/arch/linux-arm/ -fno-builtin-sin -fno-strict-volatile-bitfields -Wno-psabi -mthumb-interwork -DANDROID -fmessage-length=0 -W -Wall -Wno-unused -Winit-self -Wpointer-arith -Werror=return-type -Werror=non-virtual-dtor -Werror=address -Werror=sequence-point -DNDEBUG -g -Wstrict-aliasing=2 -fgcse-after-reload -frerun-cse-after-loop -frename-registers -DNDEBUG -UDEBUG     -Wa,\"-I\" -Wa,\"external/sonivox/arm-wt-22k/lib_src\" -Wa,\"--defsym\" -Wa,\"SAMPLE_RATE_22050=1\" -Wa,\"--defsym\" -Wa,\"STEREO_OUTPUT=1\" -Wa,\"--defsym\" -Wa,\"FILTER_ENABLED=1\" -Wa,\"--defsym\" -Wa,\"SAMPLES_8_BIT=1\"   -D__ASSEMBLY__ -MD -MF out/target/product/generic/obj/SHARED_LIBRARIES/libsonivox_intermediates/lib_src/ARM-E_filter_gnu.d -o out/target/product/generic/obj/SHARED_LIBRARIES/libsonivox_intermediates/lib_src/ARM-E_filter_gnu.o external/sonivox/arm-wt-22k/lib_src/ARM-E_filter_gnu.s"
            )?,
            None
        );
        assert_eq!(
            get_depfile(
                "echo \"RenderScript: Galaxy4 <= packages/wallpapers/Galaxy4/src/com/android/galaxy4/galaxy.rs\" && rm -rf out/target/common/obj/APPS/Galaxy4_intermediates/src/renderscript && mkdir -p out/target/common/obj/APPS/Galaxy4_intermediates/src/renderscript/res/raw && mkdir -p out/target/common/obj/APPS/Galaxy4_intermediates/src/renderscript/src && out/host/linux-x86/bin/llvm-rs-cc -o out/target/common/obj/APPS/Galaxy4_intermediates/src/renderscript/res/raw -p out/target/common/obj/APPS/Galaxy4_intermediates/src/renderscript/src -d out/target/common/obj/APPS/Galaxy4_intermediates/src/renderscript -a out/target/common/obj/APPS/Galaxy4_intermediates/src/RenderScript.stamp -MD -target-api 14 -Wall -Werror  -I prebuilts/sdk/renderscript/clang-include -I prebuilts/sdk/renderscript/include packages/wallpapers/Galaxy4/src/com/android/galaxy4/galaxy.rs && mkdir -p out/target/common/obj/APPS/Galaxy4_intermediates/src/ && touch out/target/common/obj/APPS/Galaxy4_intermediates/src/RenderScript.stamp"
            )?,
            None
        );
        assert_eq!(
            get_depfile_and_cmd(
                "(echo \"bc: libclcore.bc <= frameworks/rs/driver/runtime/arch/generic.c\") && (mkdir -p out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/) && (prebuilts/clang/linux-x86/host/3.6/bin/clang -Iframeworks/rs/scriptc -Iexternal/clang/lib/Headers -MD -DRS_VERSION=23 -std=c99 -c -O3 -fno-builtin -emit-llvm -target armv7-none-linux-gnueabi -fsigned-char   -Iframeworks/rs/cpu_ref -DRS_DECLARE_EXPIRED_APIS -Xclang -target-feature -Xclang +long64  frameworks/rs/driver/runtime/arch/generic.c -o out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.bc) && (cp out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.d out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.P; sed -e 's/#.*//' -e 's/^[^:]*: *//' -e 's/ *\\$$//' -e '/^$$/ d' -e 's/$$/ :/' < out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.d >> out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.P; rm -f out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.d)"
            )?,
            (
                Some("out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.d".into()),
                "(echo \"bc: libclcore.bc <= frameworks/rs/driver/runtime/arch/generic.c\") && (mkdir -p out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/) && (prebuilts/clang/linux-x86/host/3.6/bin/clang -Iframeworks/rs/scriptc -Iexternal/clang/lib/Headers -MD -DRS_VERSION=23 -std=c99 -c -O3 -fno-builtin -emit-llvm -target armv7-none-linux-gnueabi -fsigned-char   -Iframeworks/rs/cpu_ref -DRS_DECLARE_EXPIRED_APIS -Xclang -target-feature -Xclang +long64  frameworks/rs/driver/runtime/arch/generic.c -o out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.bc) && (cp out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.d out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.P; sed -e 's/#.*//' -e 's/^[^:]*: *//' -e 's/ *\\$$//' -e '/^$$/ d' -e 's/$$/ :/' < out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.d >> out/target/product/generic/obj/SHARED_LIBRARIES/libclcore.bc_intermediates/arch/generic.P)".into()
            )
        );
        assert_eq!(get_depfile("gcc -c foo.P.c")?, None);
        assert_eq!(get_depfile("gcc -MMD foo.o -o foo")?, None);
        // TODO: Fix for automake.
        // assert_eq!(get_depfile("(/bin/sh ./libtool  --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I./src -I./src     -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare  -DNO_FRAME_POINTER  -DNDEBUG -g -O2 -MT libglog_la-logging.lo -MD -MP -MF .deps/libglog_la-logging.Tpo -c -o libglog_la-logging.lo `test -f 'src/logging.cc' || echo './'`src/logging.cc) && (mv -f .deps/libglog_la-logging.Tpo .deps/libglog_la-logging.Plo)")?, Some(".deps/libglog_la-logging.Plo".into()));
        // assert_eq!(get_depfile("(g++ -DHAVE_CONFIG_H -I. -I./src  -I./src  -pthread     -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare  -DNO_FRAME_POINTER  -g -O2 -MT signalhandler_unittest-signalhandler_unittest.o -MD -MP -MF .deps/signalhandler_unittest-signalhandler_unittest.Tpo -c -o signalhandler_unittest-signalhandler_unittest.o `test -f 'src/signalhandler_unittest.cc' || echo './'`src/signalhandler_unittest.cc) && (mv -f .deps/signalhandler_unittest-signalhandler_unittest.Tpo .deps/signalhandler_unittest-signalhandler_unittest.Po)")?, Some(".deps/signalhandler_unittest-signalhandler_unittest.Po".into()));
        Ok(())
    }
}
